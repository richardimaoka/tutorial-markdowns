---
title: "protobufとgrpcのGoコード生成先ディレクトリの指定を、protocコマンドのオプションで行う"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["protobuf", "grpc"]
published: false
---

[gRPC 公式の Quick start](https://grpc.io/docs/languages/go/quickstart/)を見ると、以下のコマンドが載っているのですが、ちょっと複雑でドキュメントを読んだだけではきちんと理解できませんでした。

```
protoc --go_out=. --go_opt=paths=source_relative \
  --go-grpc_out=. --go-grpc_opt=paths=source_relative \
  helloworld/helloworld.proto
```

そこで、手を動かしながら`protoc`コマンドで Go コードを生成してみた記録を本記事にまとめます。

:::details 簡単のため `--go_out` と `--go_opt` だけに注目

先程のコマンドを実行すると以下で示す 2 つのファイルが生成されます。

```
+ project_root_dir
  + helloworld
     | helloworld.proto
     | helloworld.pb.go      // <- 生成されたGoコード
     | helloworld_grpc.pb.go // <- 生成されたGoコード
```

`protoc`コマンドの 4 つのオプション`--go_out` `--go_opt` `--go-grpc_out` `--go-grpc_opt` は、生成された Go コードがどのディレクトリに保存されるかを制御していて、まとめるとこうです。

|                     | `_out`オプション | `_opt` オプション | 生成ファイル名    |
| ------------------- | ---------------- | ----------------- | ----------------- |
| protobuf コード生成 | `--go_out`       | `--go_opt`        | `hello.pb.go`     |
| grpc コード生成     | `--go-grpc_out`  | `--go-grpc_opt`   | `hell_grpc.pb.go` |

前半 2 つの「protobuf コード生成」に関わる`--go_out` と `--go_opt`が理解できれば、後半 2 つも同時に理解できます。そこで、本記事ではこれより先は`--go_out` と `--go_opt`だけに注目します。

```
protoc --go_out=. --go_opt=paths=source_relative \
  helloworld/helloworld.proto
```

上記のように、注目すべきコマンドがスッキリしました！

:::

## 0. 事前準備

まずは作業用ディレクトリを準備します。

```sh:コマンドを実行して下さい
mkdir protoc-go-experiments
cd protoc-go-experiments
```

つぎに `helloworld` ディレクトリを準備します。

```sh:コマンドを実行して下さい
mkdir helloworld
cd helloworld # protoc-go-experiments/helloworld
```

```sh:コマンド実行結果
# ディレクトリ構造
+ protoc-go-experiments
  + helloworld # カレント・ディレクトリ
```

そして`helloworld.proto`ファイルを作成しましょう。

```sh:コマンドを実行して下さい
# protoc-go-experiments/helloworld/helloworld.proto
cat << EOF > helloworld.proto
syntax = "proto3";

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
EOF
```

以下のようなディレクトリ構成で準備完了です。

```sh:コマンド実行結果
+ protoc-go-experiments
  + helloworld # <- カレントディレクトリ
     | helloworld.proto
```

## 1. `.proto`ファイルと同じディレクトリから`protoc`実行

それでは`.proto`ファイルが配置されている、`helloworld`ディレクトリ内から`protoc`コマンドを実行します。

```sh:コマンドを実行して下さい
# protoc-go-experiments/helloworld ディレクトリ内で以下を実行
protoc helloworld.proto # 引数で`.proto`ファイル名のみ指定
```

```sh:エラー発生
Missing output directives.
```

### 1.1 エラーを解決しながら動作を学ぶ

このエラーは `--go_out` オプションの指定で解決できます。

> The argument to the `go_out` flag is the directory where you want the compiler to write your Go output. - [Protocol Buffers 公式: Go Generated Code](https://developers.google.com/protocol-buffers/docs/reference/go-generated)

まずは「`--go_out=.`という形で、`=`の右側には`.`を置くものである」という単純化したルールを仮定します。

```sh:コマンドを実行して下さい
protoc --go_out=. helloworld.proto
```

すると、以下のエラーが表示されます。

```sh:エラー発生
protoc-gen-go: unable to determine Go import path for "helloworld.proto"

Please specify either:
• a "go_package" option in the .proto source file, or
• a "M" argument on the command line.

See https://developers.google.com/protocol-buffers/docs/reference/go-generated#package for more information.
```

上記のリンク先 [https://developers.google.com/protocol-buffers/docs/reference/go-generated#package](https://developers.google.com/protocol-buffers/docs/reference/go-generated#package) に従って、`.proto`ファイル内で`go_package`を指定しましょう。

::: details a "M" argument on the command line. はどうなる？

```sh
Please specify either:
• a "go_package" option in the .proto source file, or
• a "M" argument on the command line.
```

というエラーメッセージからわかるように、`go_package` の指定以外にも`"M"`フラグを使う方法があります。より具体的には`--go_opt`に`M${PROTO_FILE}=${GO_IMPORT_PATH}`という形式でパッケージを指定する方法で、上記リンク先にも説明があります。

しかし、本記事では`go_package` を指定する方法のみを解説し、`--go_opt`に`M${PROTO_FILE}=${GO_IMPORT_PATH}`という形式を利用する方法は、機会があれば別の記事で紹介したいと思います。「

:::

[Go パッケージ・パスの慣習](https://go.dev/blog/package-names)に従うと、 Go パッケージは (github.com 前提で開発する場合) `github.com/__github_username` 以下に作成することになるので、`go_package` を次のように指定します。

```diff:helloworld.proto を書き換えて下さい
syntax = "proto3";

// __github_username は自身のものに置き換えて下さい。
+ option go_package = "github.com/__github_username /protoc-go-experiments/helloworld";

// The greeting service definition.
service Greeter {
```

もう一度先程のコマンドを実行します。

```sh:コマンドを実行して下さい
protoc --go_out=. helloworld.proto
```

深くネストしたディレクトリ構造になりました。

```sh:コマンド実行結果
+ protoc-go-experiments
  + helloworld
     | helloworld.proto
     + github.com # <- これ以下が生成されたGoコード
        + __github_username
          + protoc-go-experiments
            + helloworld
              | helloworld.pb.go
```

このディレクトリ構造は扱いづらいので、いったん生成結果を削除します。

```sh:コマンドを実行して下さい
rm -rf github.com
```

`.proto`ファイルのみが残ります。

```sh:コマンド実行結果
+ protoc-go-experiments
  + helloworld
     | helloworld.proto
```

これで、次の実験への準備ができました。

### 1.2 `--go_opt`に`paths=source_relative`を指定

ネストを避けるため、`--go_opt`に`paths=source_relative`をつけます。

> If the `paths=source_relative` flag is specified, the output file is placed in the same relative directory as the input file. - [Protocol Buffers 公式: Go Generated Code](https://developers.google.com/protocol-buffers/docs/reference/go-generated)

```sh:コマンドを実行して下さい
protoc \
  --go_out=. --go_opt=paths=source_relative \
  helloworld.proto
```

ディレクトリ構造がスッキリしました。

```sh:コマンド実行結果
+ protoc-go-experiments
  + helloworld
     | helloworld.proto
     | helloworld.pb.go  # <- これが生成されたGoコード
```

それではここで生成した Go コードを一旦消去しましょう。

```sh:コマンドを実行して下さい
rm helloworld.pb.go
```

`.proto`ファイルのみが残ります。

```sh:コマンド実行結果
+ protoc-go-experiments
  + helloworld
     | helloworld.proto
```

これで、次の実験への準備ができました。

## 1.3 `--go_out`の変更

これまでは以下の仮定のもと進めてきました。

> まずは「`--go_out=.`という形で、`=`の右側には`.`を置くものである」という単純化したルールを仮定します。

ここでは、その仮定を変えて、`--go_out`に違う値`outdir`を指定してみます。

```sh:コマンドを実行して下さい
protoc \
  --go_out=outdir --go_opt=paths=source_relative \
  helloworld.proto
```

```sh:エラー発生
outdir/: No such file or directory
```

`outdir`が存在しないことでエラーになってしまったので、`outdir`を作成します。

```sh:コマンドを実行して下さい
mkdir outdir
```

```sh:コマンド実行結果
+ protoc-go-experiments
  + helloworld
     | helloworld.proto
     + outdir
```

先程のコマンドをもう一度実行します。

```sh:コマンドを実行して下さい
protoc \
  --go_out=outdir --go_opt=paths=source_relative \
  helloworld.proto
```

```sh:コマンド実行結果
+ protoc-go-experiments
  + helloworld
     | helloworld.proto
     + outdir
       | helloworld.pb.go # <- これが生成されたGoコードo
```

これで、`--go_opt=paths=source_relative`と指定したときに、`-go_out`でどのように Go コード生成先ディレクトリを制御できるかわかりました。

それでは生成した Go コードを一旦消去しましょう。

```sh:コマンドを実行して下さい
rm -rf outdir
```

`.proto`ファイルのみが残ります。

```sh:コマンド実行結果
+ protoc-go-experiments
  + helloworld
     | helloworld.proto
```

これで、次の実験への準備ができました。

### 1.4 ここまでのまとめ

- Go コード生成には`--go_out`オプションを指定する。
- `--go_opt=paths=source_relative` をつけると `github.com/__github_username/...` という深くネストされたディレクトリに保存されなくなる
- `--go_opt=paths=source_relative` のもとで、`--go_out=outidr`のような指定で、Go コード生成先ディレクトリを制御できる

## 2. プロジェクトルートから`protoc`を実行

多くの grpc 利用プロジェクトでは、プロジェクトルート・ディレクトリから`protoc`を実行することと思います。本記事でもここからはプロジェクトルートに移動して`protoc`を試します。

```sh:コマンドを実行して下さい
cd ../
```

```sh:コマンド実行結果
+ protoc-go-experiments # <- カレントディレクトリ
  + helloworld
     | helloworld.proto
```

先ほどと同じコマンドを実行します。

```sh:コマンドを実行して下さい
protoc \
  --go_out=. --go_opt=paths=source_relative \
  helloworld.proto
```

```sh:エラー発生
helloworld.proto: No such file or directory
```

エラーを解決するため、引数`helloworld.proto`を`helloworld/helloworld.proto`に変えます。

```sh:コマンドを実行して下さい
protoc \
  --go_out=. --go_opt=paths=source_relative \
  helloworld/helloworld.proto
```

1. のときと同じ生成結果を再現できました。

```sh:コマンド実行結果
+ protoc-go-experiments
  + helloworld
     | helloworld.proto
     | helloworld.pb.go  # <- これが生成されたGoコード
```

それでは生成した Go コードを一旦消去しましょう。

```sh:コマンドを実行して下さい
rm -rf helloworld/helloworld/pb.go
```

`.proto`ファイルのみが残ります。

```sh:コマンド実行結果
+ protoc-go-experiments
  + helloworld
     | helloworld.proto
```

これで、次の実験への準備ができました。

## 2.1 `--proto_path` (省略形は`-I`)オプションをつける

```sh:コマンドを実行して下さい
protoc --proto_path=proto \
  --go_out=. --go_opt=paths=source_relative \
  helloworld.proto
```

こうなる。これは困る…？

```
./hello.pb.go
./proto/helloworld.proto
```

```
rm hello.pb.go
```

`--proto_path`やめて`proto/helloworld.proto`で指定

```sh
protoc --go_out=. --go_opt=paths=source_relative  proto/helloworld.proto
```

```
./proto/hello.pb.go
./proto/helloworld.proto
```

```
rm proto/hello.pb.go
```

https://developers.google.com/protocol-buffers/docs/reference/go-generated

> If the paths=source_relative flag is specified, the output file is placed in the same relative directory as the input file. For example, an input file protos/buzz.proto results in an output file at protos/buzz.pb.go.

`--proto_path`を指定しながら、引数`proto/helloworld.proto`で指定

```sh
protoc --go_out=. --go_opt=paths=source_relative  proto/helloworld.proto
```

先程の`--proto_path`を指定しながら、引数`helloworld.proto`で指定したものと同じ状況に

```
./hello.pb.go
./proto/helloworld.proto
```

```sh
rm hello.pb.go
```

`--proto_path`指定はこちらのルールに従うのが良いのでは？

https://developers.google.com/protocol-buffers/docs/proto3

> In general you should set the --proto_path flag to the root of your project and use fully qualified names for all imports.

### 2. 複数ファイル

### 2. まとめ

`--proto_path`を使用する必要がないときは使用を避け、プロジェクトルートからのパスで.proto ファイルを指定するのが良さそう。

## 3. module

`--go_opt=module=...`指定をするとまた話が変わってくる…→Udemy Clement-Jean 　[このビデオの 5:40](https://www.udemy.com/course/grpc-golang/learn/lecture/11018752#content)あたりを見ると、`--go_opt=module=github.com/Clement-Jean/grpc` を指定すると、.proto ファイル内の

```
option go_package = "github.com/Clement-Jean/grpc/greet/proto";
```

の部分のうち一致する部分を「削り取って」、

```
# 一致部分が削られた
greet/proto
```

このパスを`--go_out=.`に append して、.pb.go ファイルを吐き出すディレクトリを決めている。
