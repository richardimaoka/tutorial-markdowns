---
title: "コピペで学ぶチュートリアル: DockerfileのCMDとENTRYPOINTの違い"
emoji: "🐷"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["docker"]
published: false
---

Dockerfile の CMD と ENTRYPOINT について、手を動かして動作確認できるチュートリアルもあると理解がしやすいかと思い、コピペだけで簡単に学べるチュートリアルを作成しました。

:::details それぞれの違いについては公式ドキュメントでも、数多くのブログ記事などでも解説されています。

- [Dockerfile reference](https://docs.docker.com/engine/reference/builder/#cmd)
- [Best practices for writing Dockerfiles](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#cmd)
- [ENTRYPOINT は「必ず実行」、CMD は「（デフォルトの）引数」](https://pocketstudio.net/2020/01/31/cmd-and-entrypoint/) - POCKETSTUDIO.NET (前佛 雅人さんのブログ)

ここに挙げただけでなく、数え切れないくらい多くの記事で解説されています。
:::

## 事前準備

まずは今回のチュートリアルで利用する Dockerfile が保存されている GitHub レポジトリをクローンします。

```
git clone git@github.com:richardimaoka/tutorial-docker-cmd-entrypoint.git
cd tutorial-docker-cmd-entrypoint
```

## CMD の動作理解

まずは CMD だけを先に理解するため、いったん ENTRYPOINT のことを忘れます。これは両者がとても似ていて、同時に理解しようとすると混乱するからです。

### JSON array 形式の exec form

```dockerfile:Dockerfile.cmd1
FROM ubuntu
CMD ["echo", "abc"]
```

上記の Dockerfile を build して run しましょう。冒頭でクローンした GitHub レポジトリに Dockerfile.cmd1 というファイルが含まれているので、以下のコマンドをターミナルで実行してください。

```:以下のコマンドを実行してください
docker build -t cmd1 -f Dockerfile.cmd1 .
docker run --name cnt-cmd1 --rm cmd1
```

```:docker runの結果
abc
```

次はこちらの Dockerfile です。echo コマンドに渡す引数が 1 つ増えました。

```dockerfile:Dockerfile.cmd2
FROM ubuntu
CMD ["echo", "abc", "def"]
```

```:以下のコマンドを実行してください
docker build -t cmd2 -f Dockerfile.cmd2 .
docker run --name cnt-cmd2 --rm cmd2
```

```:コマンドの実行結果
abc def
```

上記 2 例の Dockerfile の CMD は exec form と呼ばれる形式で、[Dockerfile リファレンス](https://docs.docker.com/engine/reference/builder/#cmd)に、

> this is the preferred form

とあるように、CMD の記述には基本的にこの exec form を使うべきです。

### shell form

しかし、CMD にはもう一つ、shell form と呼ばれる以下の記法があります。

```dockerfile:Dockerfile.cmd3
FROM ubuntu
CMD echo "abc"
```

```:以下のコマンドを実行してください
docker build -t cmd3 -f Dockerfile.cmd3 .
docker run --name cnt-cmd3 --rm cmd3
```

```:コマンドの実行結果
abc
```

shell form で 2 つの引数を渡してみましょう。

```dockerfile:Dockerfile.cmd4
FROM ubuntu
CMD echo "abc" "def"
```

```:以下のコマンドを実行してください
docker build -t cmd4 -f Dockerfile.cmd4 .
docker run --name cnt-cmd4 --rm cmd4
```

```:コマンドの実行結果
abc def
```

### shell form と exec form によるシェル変数展開

shell form では以下のようにシェル変数の展開も出来ます。

```dockerfile:Dockerfile.cmd5
FROM ubuntu
CMD echo "$HOME"
```

```:以下のコマンドを実行してください
docker build -t cmd5 -f Dockerfile.cmd5 .
docker run --name cnt-cmd5 --rm cmd5
```

```:コマンドの実行結果
/home/your_username
```

シェル変数の展開を exec form で行うとなると、少しだけ面倒な記述になります。

```dockerfile:Dockerfile.cmd6
FROM ubuntu
CMD [ "sh", "-c", "echo $HOME" ]
```

```:以下のコマンドを実行してください
docker build -t cmd6 -f Dockerfile.cmd6 .
docker run --name cnt-cmd6 --rm cmd6
```

```:コマンドの実行結果
/home/your_username
```

### なぜ exec form を優先すべきで、shell form はそうではないのか？

ここまで exec form でも shell form でも同じことが出来る例を見てきました。ここからは両者の違いと、exec form を優先すべき理由の一つを説明します。

```:以下のコマンドを実行してください
docker run nginx:1.23.1
```

これで、nginx によるウェブサーバーが立ち上がります。

```:コマンド実行結果
2022/09/03 07:14:58 [notice] 1#1: using the "epoll" event method
2022/09/03 07:14:58 [notice] 1#1: nginx/1.23.1
2022/09/03 07:14:58 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)
2022/09/03 07:14:58 [notice] 1#1: OS: Linux 5.10.102.1-microsoft-standard-WSL2
2022/09/03 07:14:58 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576
2022/09/03 07:14:58 [notice] 1#1: start worker processes
2022/09/03 07:14:58 [notice] 1#1: start worker process 31
2022/09/03 07:14:58 [notice] 1#1: start worker process 32
2022/09/03 07:14:58 [notice] 1#1: start worker process 33
2022/09/03 07:14:58 [notice] 1#1: start worker process 34
2022/09/03 07:14:58 [notice] 1#1: start worker process 35
2022/09/03 07:14:58 [notice] 1#1: start worker process 36
2022/09/03 07:14:58 [notice] 1#1: start worker process 37
2022/09/03 07:14:58 [notice] 1#1: start worker process 38
```

nginx を停止してみましょう。

```:以下のショートカットを実行してください
Ctrl + c
```

これで SIGINT が送られ…

```:ショートカット実行結果
2022/09/03 07:15:40 [notice] 1#1: signal 2 (SIGINT) received, exiting
2022/09/03 07:15:40 [notice] 1#1: signal 14 (SIGALRM) received
...
...
2022/09/03 07:15:40 [notice] 1#1: worker process 38 exited with code 0
2022/09/03 07:15:40 [notice] 1#1: exit
```

…nginx が停止しました。

Ctrl+c できれいに停止できるのは、nginx の docker イメージが CMD の exec form を使っているからです。

```:以下のコマンドを実行してください
docker inspect nginx
```

CMD の exec form を使っていることが確認できます。

```:コマンド実行結果
"Config": {
    "Cmd": [
        "nginx",
        "-g",
        "daemon off;"
    ]
}
```

それでは、shell form を使って nginx を立ち上げるとどうなるか見てみましょう。

```dockerfile:Dockerfile.cmd-nginx
FROM nginx:1.23.1
CMD nginx -g "daemon off;"
```

```:以下のコマンドを実行してください
docker build -t cmd-nginx -f Dockerfile.cmd-nginx .
docker run --name cnt-cmd-nginx --rm cmd-nginx
```

```:以下のショートカットを実行してください
Ctrl + c
```

```実行結果
2022/09/03 05:48:46 [notice] 7#7: start worker process 13
2022/09/03 05:48:46 [notice] 7#7: start worker process 14
2022/09/03 05:48:46 [notice] 7#7: start worker process 15
^C
```

nginx が停止しません！

代わりに、別ターミナルで docker stop を実行すればこれを停止できます。

```:以下のコマンドを実行してください
docker stop cnt-cmd-nginx
```

先ほどと違って`signal 2 (SIGINT) received, exiting`とは表示されずに、急に nginx のログが出力されなくなり停止しました。

:::details docker stop で停止できる理由

[docker stop のリファレンス](https://docs.docker.com/engine/reference/commandline/stop/#description)にあるとおり、最初に SIGTERM が送られるのですが…

> The main process inside the container will receive SIGTERM, and after a grace period, SIGKILL. The first signal can be changed with the STOPSIGNAL instruction in the container’s Dockerfile, or the --stop-signal option to docker run.

…CMD に shell form を使っていることにより SIGTERM は無視され(理由は後述)、2 番めに送られる SIGKILL によって nginx が強制終了されるためです。
:::

:::details Ctrl+c で送ったのは SIGINT であり SIGTERM ではないので、比較になっていないのでは？

SIGINT でも SIGTERM でほぼ同じ結果になります。

```:以下のコマンドを実行してください
docker run nginx
```

別ターミナルで`docker kill`を使って SIGTERM を送ります。

```:以下のコマンドを実行してください
docker kill --signal SIGTERM cnt-cmd-nginx
```

SIGTERM でも SIGINT と同様 nginx は停止します。

```:コマンド実行結果
2022/09/03 06:04:49 [notice] 1#1: signal 15 (SIGTERM) received, exiting
2022/09/03 06:04:49 [notice] 31#31: exiting
...
...
2022/09/03 06:04:49 [notice] 1#1: worker process 38 exited with code 0
2022/09/03 06:04:49 [notice] 1#1: exit
```

それでは、shell form を使った場合に Ctrl+c で送信される SIGINT を送信するとどうなるでしょう？

```:以下のコマンドを実行してください
docker build -t cmd-nginx -f Dockerfile.cmd-nginx .
docker run --name cnt-cmd-nginx cmd-nginx
```

別ターミナルで`docker kill`を使って SIGINT を送ります。

```:以下のコマンドを実行してください
docker kill --signal SIGINT cnt-cmd-nginx
```

shell form では、SIGTERM 同様 SIGINT も無視され、nginx は走り続けます。

```コマンド実行結果
2022/09/03 05:48:46 [notice] 7#7: start worker process 14
2022/09/03 05:48:46 [notice] 7#7: start worker process 15
```

:::

以上のように、プロセス・シグナルを受け取れなくなってしまうことが、shell form の欠点であり、exec form を使うべき大きな理由です。

### exec form と shell form の PID 1 を比較する

shell form でプロセス・シグナルを受け取れなくなってしまうのは、CMD で指定したコマンドがコンテナ内のプロセス ID`PID 1`にならないからです。

exec form で、CMD のコマンドとコンテナ内の`PID 1`の一致を確かめましょう。

```dockerfile:Dockerfile.cmd7
FROM ubuntu
CMD ["tail", "-f", "/dev/null"]
```

```:以下のコマンドを実行してください
docker build -t cmd7 -f Dockerfile.cmd7 .
docker run --name cnt-cmd7 --rm cmd7
```

何も表示されずプロセスが立ち上がったままになるので、別ターミナルからコンテナ内部に入ります。

```:以下のコマンドを実行してください
docker exec -it cnt-cmd7 /bin/sh
```

これでコンテナ内部に入り込めたので、`ps` コマンドでコンテナ内部のプロセス一覧を表示します。

```:以下のコマンドを実行してください
ps -eaf
```

CMD で指定したコマンド`tail`が`PID 1`になっていることがわかります。

```:コマンド実行結果
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 06:49 ?        00:00:00 tail -f /dev/null
root         7     0  1 06:50 pts/0    00:00:00 /bin/sh
root        13     7  0 06:50 pts/0    00:00:00 ps -eaf
```

コンテナ内から抜けましょう。

```:以下のコマンドを実行してください
exit
```

`tail` コマンドは `nginx` とは違って `SIGTERM`を受け付けて終了してくれないので、`SIGKILL`で強制終了します。

```:以下のコマンドを実行してください
docker kill --signal SIGKILL cnt-cmd7
```

次に、shell form の CMD です。`PID 1`が`tail`にならないことを確かめましょう。

```dockerfile:Dockerfile.cmd8
FROM ubuntu
CMD tail -f /dev/null
```

```:以下のコマンドを実行してください
docker build -t cmd8 -f Dockerfile.cmd8 .
docker run --name cnt-cmd8 --rm cmd8
```

何も表示されずに、プロセスが立ち上がったままになるので、別ターミナルで以下を実行してください

```:以下のコマンドを実行してください
docker exec -it cnt-cmd8 /bin/sh
```

これでコンテナ内部に入り込めたので、`ps` コマンドでコンテナ内部のプロセス一覧を表示します。

```:以下のコマンドを実行してください
ps -eaf
```

注意してみないと分かりづらいですが、`PID 1`が`/bin/sh`になっています。`tail`は`PID 7`です。

```:コマンド実行結果
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 06:37 ?        00:00:00 /bin/sh -c tail -f /dev/null
root         7     1  0 06:37 ?        00:00:00 tail -f /dev/null
root         8     0  0 06:40 pts/0    00:00:00 /bin/sh
root        15     8  0 06:41 pts/0    00:00:00 ps -eaf
```

```:以下のコマンドを実行してください
exit
```

`SIGKILL`で強制終了します。

```:以下のコマンドを実行してください
docker kill --signal SIGKILL cnt-cmd8
```

## ENTRYPOINT の動作理解

CMD の次は ENTRYPOINT の動作理解です。ここでも ENTRYPOINT の動作だけに集中して、CMD のことは忘れます。

### JSON array 形式の exec form

```dockerfile:Dockerfile.entrypoint1
FROM ubuntu
ENTRYPOINT ["echo", "abc"]
```

上記の Dockerfile を build して run しましょう

```:以下のコマンドを実行してください
docker build -t entrypoint1 -f Dockerfile.entrypoint1 .
docker run --name cnt-entrypoint1 --rm entrypoint1
```

```:コマンドの実行結果
abc
```

次はこちらの Dockerfile です。echo コマンドに渡す引数が 1 つ増えました。

```dockerfile:Dockerfile.entrypoint2
FROM ubuntu
ENTRYPOINT ["echo", "abc", "def"]
```

```:以下のコマンドを実行してください
docker build -t entrypoint2 -f Dockerfile.entrypoint2 .
docker run --name cnt-entrypoint2 --rm entrypoint2
```

```:コマンドの実行結果
abc def
```

上記 2 例の Dockerfile の ENTRYPOINT は exec form と呼ばれる形式で、[Dockerfile リファレンス](The exec form, which is the preferred form:)に、

> The exec form, which is the preferred form

とあるように、ENTRYPOINT の記述も基本的にこの exec form を使うべきです。

### shell form

ENTRYPOINT にはもう一つ、shell form と呼ばれる以下の記法があります。

```dockerfile:Dockerfile.entrypoint3
FROM ubuntu
ENTRYPOINT echo "abc"
```

```:以下のコマンドを実行してください
docker build -t entrypoint3 -f Dockerfile.entrypoint3 .
docker run --name cnt-entrypoint3 --rm entrypoint3
```

```:コマンドの実行結果
abc
```

shell form で 2 つの引数を渡してみましょう。

```dockerfile:Dockerfile.entrypoint4
FROM ubuntu
ENTRYPOINT echo "abc" "def"
```

```:以下のコマンドを実行してください
docker build -t entrypoint4 -f Dockerfile.entrypoint4 .
docker run --name cnt-entrypoint4 --rm entrypoint4
```

```:コマンドの実行結果
abc def
```

### shell form と exec form によるシェル変数展開

shell form では以下のようにシェル変数の展開も出来ます。

```dockerfile:Dockerfile.entrypoint5
FROM ubuntu
ENTRYPOINT echo "$HOME"
```

```:以下のコマンドを実行してください
docker build -t entrypoint5 -f Dockerfile.entrypoint5 .
docker run --name cnt-entrypoint5 --rm entrypoint5
```

```:コマンドの実行結果
/home/your_username
```

シェル変数の展開を exec form で行うとなると、少しだけ面倒な記述になります。

```dockerfile:Dockerfile.entrypoint6
FROM ubuntu
ENTRYPOINT [ "sh", "-c", "echo $HOME" ]
```

```:以下のコマンドを実行してください
docker build -t entrypoint6 -f Dockerfile.entrypoint6 .
docker run --name cnt-entrypoint6 --rm entrypoint6
```

```:コマンドの実行結果
/home/your_username
```

### なぜ exec form を優先すべきで、shell form はそうではないのか？

ここまで exec form でも shell form でも同じことが出来る例を見てきました。ここからは両者の違いと、exec form を優先すべき理由の一つを説明します。

```dockerfile:Dockerfile.entrypoint-nginx1
FROM nginx:1.23.1
ENTRYPOINT [ "nginx", "-g", "daemon off;"]
```

```:コマンド実行結果
2022/09/03 07:14:58 [notice] 1#1: using the "epoll" event method
2022/09/03 07:14:58 [notice] 1#1: nginx/1.23.1
2022/09/03 07:14:58 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)
2022/09/03 07:14:58 [notice] 1#1: OS: Linux 5.10.102.1-microsoft-standard-WSL2
2022/09/03 07:14:58 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576
2022/09/03 07:14:58 [notice] 1#1: start worker processes
2022/09/03 07:14:58 [notice] 1#1: start worker process 31
2022/09/03 07:14:58 [notice] 1#1: start worker process 32
2022/09/03 07:14:58 [notice] 1#1: start worker process 33
2022/09/03 07:14:58 [notice] 1#1: start worker process 34
2022/09/03 07:14:58 [notice] 1#1: start worker process 35
2022/09/03 07:14:58 [notice] 1#1: start worker process 36
2022/09/03 07:14:58 [notice] 1#1: start worker process 37
2022/09/03 07:14:58 [notice] 1#1: start worker process 38
```

nginx を停止してみましょう。

```:以下のショートカットを実行してください
Ctrl + c
```

これで SIGINT が送られ…

```:ショートカット実行結果
2022/09/03 07:15:40 [notice] 1#1: signal 2 (SIGINT) received, exiting
2022/09/03 07:15:40 [notice] 1#1: signal 14 (SIGALRM) received
...
...
2022/09/03 07:15:40 [notice] 1#1: worker process 38 exited with code 0
2022/09/03 07:15:40 [notice] 1#1: exit
```

…nginx が停止しました。

Ctrl+c できれいに停止できるのは、先程ファイル`Dockerfile.entrypoint-nginx1`で見たように、ENTRYPOINT の exec form を使っているからです。

それでは、shell form を使って nginx を立ち上げるとどうなるか見てみましょう。

```dockerfile:Dockerfile.entrypoint-nginx2
FROM nginx:1.23.1
ENTRYPOINT nginx -g "daemon off;"
```

```:以下のコマンドを実行してください
docker build -t entrypoint-nginx2 -f Dockerfile.entrypoint-nginx2 .
docker run --name cnt-entrypoint-nginx2 --rm entrypoint-nginx2
```

```:以下のショートカットを実行してください
Ctrl + c
```

```実行結果
2022/09/03 05:48:46 [notice] 7#7: start worker process 13
2022/09/03 05:48:46 [notice] 7#7: start worker process 14
2022/09/03 05:48:46 [notice] 7#7: start worker process 15
^C
```

nginx が停止しません！

代わりに、別ターミナルで docker stop を実行すればこれを停止できます。

```:以下のコマンドを実行してください
docker stop cnt-entrypoint-nginx2
```

先ほどと違って`signal 2 (SIGINT) received, exiting`とは表示されずに、急に nginx のログが出力されなくなり停止しました。

:::details docker stop で停止できる理由

[docker stop のリファレンス](https://docs.docker.com/engine/reference/commandline/stop/#description)にあるとおり、最初に SIGTERM が送られるのですが…

> The main process inside the container will receive SIGTERM, and after a grace period, SIGKILL. The first signal can be changed with the STOPSIGNAL instruction in the container’s Dockerfile, or the --stop-signal option to docker run.

…ENTRYPOINT に shell form を使っていることにより SIGTERM は無視され(理由は後述)、2 番めに送られる SIGKILL によって nginx が強制終了されるためです。
:::

:::details Ctrl+c で送ったのは SIGINT であり SIGTERM ではないので、比較になっていないのでは？

SIGINT でも SIGTERM でほぼ同じ結果になります。Ctrl+c = SIGINT で停止した exec form のコンテナを、SIGTERM で停止させてみましょう。

```:以下のコマンドを実行してください
docker run --name cnt-entrypoint-nginx1 --rm entrypoint-nginx1
```

別ターミナルで`docker kill`を使って SIGTERM を送ります。

```:以下のコマンドを実行してください
docker kill --signal SIGTERM cnt-entrypoint-nginx1
```

SIGTERM でも SIGINT と同様 nginx は停止します。

```:コマンド実行結果
2022/09/03 06:04:49 [notice] 1#1: signal 15 (SIGTERM) received, exiting
2022/09/03 06:04:49 [notice] 31#31: exiting
...
...
2022/09/03 06:04:49 [notice] 1#1: worker process 38 exited with code 0
2022/09/03 06:04:49 [notice] 1#1: exit
```

それでは、shell form を使った場合に Ctrl+c で送信される SIGINT を送信するとどうなるでしょう？

```:以下のコマンドを実行してください
docker run --name cnt-entrypoint-nginx2 --rm entrypoint-nginx2
```

別ターミナルで`docker kill`を使って SIGINT を送ります。

```:以下のコマンドを実行してください
docker kill --signal SIGINT cnt-entrypoint-nginx2
```

shell form では、SIGTERM 同様 SIGINT も無視され、nginx は走り続けます。

```コマンド実行結果
2022/09/03 05:48:46 [notice] 7#7: start worker process 14
2022/09/03 05:48:46 [notice] 7#7: start worker process 15
```

:::

以上のように、プロセス・シグナルを受け取れなくなってしまうことが、shell form の欠点であり、exec form を使うべき大きな理由です。

### exec form と shell form の PID 1 を比較する

shell form でプロセス・シグナルを受け取れなくなってしまうのは、ENTRYPOINT で指定したコマンドがコンテナ内のプロセス ID`PID 1`にならないからです。

exec form ENTRYPOINT のコマンドとコンテナ内の`PID 1`の一致を確かめましょう。

```dockerfile:Dockerfile.entrypoint7
FROM ubuntu
ENTRYPOINT ["tail", "-f", "/dev/null"]
```

```:以下のコマンドを実行してください
docker build -t entrypoint7 -f Dockerfile.entrypoint7 .
docker run --name cnt-entrypoint7 --rm entrypoint7
```

何も表示されずプロセスが立ち上がったままになるので、別ターミナルからコンテナ内部に入ります。

```:以下のコマンドを実行してください
docker exec -it cnt-entrypoint7 /bin/sh
```

これでコンテナ内部に入り込めたので、`ps` コマンドでコンテナ内部のプロセス一覧を表示します。

```:以下のコマンドを実行してください
ps -eaf
```

ENTRYPOINT で指定したコマンド`tail`が`PID 1`になっていることがわかります。

```:コマンド実行結果
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 06:49 ?        00:00:00 tail -f /dev/null
root         7     0  1 06:50 pts/0    00:00:00 /bin/sh
root        13     7  0 06:50 pts/0    00:00:00 ps -eaf
```

コンテナ内から抜けましょう。

```:以下のコマンドを実行してください
exit
```

`tail` コマンドは `nginx` とは違って `SIGTERM`を受け付けて終了してくれないので、`SIGKILL`で強制終了します。

```:以下のコマンドを実行してください
docker kill --signal SIGKILL cnt-entrypoint7
```

次に、shell form の ENTRYPOINT です。`PID 1`が`tail`にならないことを確かめましょう。

```dockerfile:Dockerfile.entrypoint8
FROM ubuntu
ENTRYPOINT tail -f /dev/null
```

```:以下のコマンドを実行してください
docker build -t entrypoint8 -f Dockerfile.entrypoint8 .
docker run --name cnt-entrypoint8 --rm entrypoint8
```

何も表示されずに、プロセスが立ち上がったままになるので、別ターミナルで以下を実行してください

```:以下のコマンドを実行してください
docker exec -it cnt-entrypoint8 /bin/sh
```

これでコンテナ内部に入り込めたので、`ps` コマンドでコンテナ内部のプロセス一覧を表示します。

```:以下のコマンドを実行してください
ps -eaf
```

注意してみないと分かりづらいですが、`PID 1`が`/bin/sh`になっています。`tail`は`PID 7`です。

```:コマンド実行結果
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 06:37 ?        00:00:00 /bin/sh -c tail -f /dev/null
root         7     1  0 06:37 ?        00:00:00 tail -f /dev/null
root         8     0  0 06:40 pts/0    00:00:00 /bin/sh
root        15     8  0 06:41 pts/0    00:00:00 ps -eaf
```

```:以下のコマンドを実行してください
exit
```

`SIGKILL`で強制終了します。

```:以下のコマンドを実行してください
docker kill --signal SIGKILL cnt-entrypoint8
```
